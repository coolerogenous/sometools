<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRT è½¬ Apple Style è§†é¢‘ç”Ÿæˆå™¨</title>
    <style>
        body {
            margin: 0;
            background-color: #1a1a1a;
            color: #eee;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* å·¦ä¾§è®¾ç½®æ  */
        .sidebar {
            width: 320px;
            background-color: #252525;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-right: 1px solid #333;
            overflow-y: auto;
            z-index: 10;
        }

        h2 { margin: 0 0 10px 0; font-size: 16px; color: #fff; border-bottom: 1px solid #444; padding-bottom: 10px; }
        
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 12px; color: #aaa; }
        
        input[type="text"], input[type="file"], input[type="number"] {
            background: #333; border: 1px solid #444; color: white;
            padding: 8px; border-radius: 4px; font-size: 13px; width: 100%; box-sizing: border-box;
        }
        input:focus { border-color: #007aff; outline: none; }

        /* æŒ‰é’®ç»„ */
        .btn {
            padding: 12px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer;
            transition: 0.2s; color: white; width: 100%; margin-top: 5px;
        }
        .btn-primary { background-color: #007aff; }
        .btn-primary:hover { background-color: #0062cc; }
        .btn-danger { background-color: #ff3b30; }
        .btn-danger:hover { background-color: #d63026; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* å³ä¾§é¢„è§ˆåŒº */
        .preview-area {
            flex-grow: 1;
            background-color: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        /* ç”»å¸ƒ */
        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            max-width: 90%;
            max-height: 85vh;
            background: #000;
        }

        .status-bar {
            margin-top: 10px;
            color: #888;
            font-family: monospace;
            font-size: 14px;
        }
        .recording-indicator {
            color: #ff3b30;
            animation: pulse 1s infinite;
            display: none;
        }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

    </style>
</head>
<body>

    <div class="sidebar">
        <h2>ğŸ› ï¸ è§†é¢‘ç”Ÿæˆè®¾ç½®</h2>

        <div class="control-group">
            <label>1. å¯¼å…¥ SRT å­—å¹•</label>
            <input type="file" id="srtInput" accept=".srt">
        </div>

        <div class="control-group">
            <label>2. æ­Œæ›²ä¿¡æ¯</label>
            <input type="text" id="songTitle" placeholder="æ­Œå" value="ç¤ºä¾‹æ­Œæ›²">
            <input type="text" id="artistName" placeholder="æ­Œæ‰‹" value="Unknown Artist">
        </div>

        <div class="control-group">
            <label>3. èƒŒæ™¯å›¾ (å¯é€‰)</label>
            <input type="file" id="bgInput" accept="image/*">
        </div>

        <div class="control-group">
            <label>è§†é¢‘å°ºå¯¸ (å®½ x é«˜)</label>
            <div style="display:flex; gap:5px;">
                <input type="number" id="vidW" value="1920">
                <input type="number" id="vidH" value="1080">
            </div>
        </div>

        <div class="control-group">
            <label>å½•åˆ¶å€é€Ÿ (æ•°å€¼è¶Šå¤§å½•åˆ¶è¶Šå¿«)</label>
            <input type="number" id="recSpeed" value="1" min="1" max="5" step="0.5" title="å¦‚æœç”µè„‘å¡é¡¿è¯·è®¾ä¸º1ï¼Œå¦‚æœæƒ³å¿«é€Ÿç”Ÿæˆè¯·è®¾ä¸º2-5">
        </div>

        <div style="margin-top: auto;">
            <button id="previewBtn" class="btn btn-primary" style="background:#444">â–¶ï¸ ä»…é¢„è§ˆæ’­æ”¾</button>
            <button id="recordBtn" class="btn btn-danger">ğŸ”´ å¼€å§‹å½•åˆ¶è§†é¢‘</button>
            <button id="stopBtn" class="btn" style="background:#333; display:none;">â¹ åœæ­¢</button>
        </div>
    </div>

    <div class="preview-area">
        <canvas id="videoCanvas"></canvas>
        <div class="status-bar">
            <span id="timeDisplay">00:00 / 00:00</span>
            <span id="recStatus" class="recording-indicator"> â— REC</span>
        </div>
    </div>

<script>
    // === é…ç½®ä¸çŠ¶æ€ ===
    const canvas = document.getElementById('videoCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI å…ƒç´ 
    const inputs = {
        srt: document.getElementById('srtInput'),
        bg: document.getElementById('bgInput'),
        title: document.getElementById('songTitle'),
        artist: document.getElementById('artistName'),
        w: document.getElementById('vidW'),
        h: document.getElementById('vidH'),
        speed: document.getElementById('recSpeed')
    };
    const btns = {
        preview: document.getElementById('previewBtn'),
        record: document.getElementById('recordBtn'),
        stop: document.getElementById('stopBtn')
    };
    const displays = {
        time: document.getElementById('timeDisplay'),
        rec: document.getElementById('recStatus')
    };

    // è¿è¡Œæ—¶å˜é‡
    let lyrics = [];
    let backgroundImg = null;
    let animationId = null;
    let state = {
        startTime: 0,
        duration: 0, // æ€»æ—¶é•¿ (ç§’)
        currentTime: 0,
        isPlaying: false,
        isRecording: false
    };

    // å½•åˆ¶ç›¸å…³
    let mediaRecorder;
    let recordedChunks = [];
    let audioContext = null; // ç”¨äºå¯èƒ½çš„éŸ³é¢‘æ··åˆï¼ˆç›®å‰ä»…è§†é¢‘ï¼‰

    // åˆå§‹åŒ–
    resizeCanvas();
    drawFrame(0); // ç»˜åˆ¶åˆå§‹å¸§

    // === äº‹ä»¶ç›‘å¬ ===
    
    // 1. SRT ä¸Šä¼ è§£æ
    inputs.srt.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            lyrics = parseSRT(e.target.result);
            if(lyrics.length > 0) {
                // è‡ªåŠ¨è®¾ç½®æ€»æ—¶é•¿ = æœ€åä¸€å¥ç»“æŸæ—¶é—´ + 3ç§’ç¼“å†²
                state.duration = lyrics[lyrics.length - 1].end + 3;
                alert(`SRT è§£ææˆåŠŸï¼å…± ${lyrics.length} è¡Œï¼Œæ€»æ—¶é•¿çº¦ ${formatTime(state.duration)}`);
                drawFrame(0);
            }
        };
        reader.readAsText(file);
    });

    // 2. èƒŒæ™¯å›¾ä¸Šä¼ 
    inputs.bg.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                backgroundImg = img;
                drawFrame(state.currentTime);
            }
            img.src = event.target.result;
        }
        reader.readAsDataURL(file);
    });

    // 3. å°ºå¯¸å˜åŒ–
    inputs.w.addEventListener('change', resizeCanvas);
    inputs.h.addEventListener('change', resizeCanvas);
    inputs.title.addEventListener('input', () => drawFrame(state.currentTime));
    inputs.artist.addEventListener('input', () => drawFrame(state.currentTime));

    // 4. æŒ‰é’®æ§åˆ¶
    btns.preview.addEventListener('click', () => togglePlayback(false));
    btns.record.addEventListener('click', () => togglePlayback(true));
    btns.stop.addEventListener('click', stopPlayback);


    // === æ ¸å¿ƒé€»è¾‘ ===

    function resizeCanvas() {
        canvas.width = parseInt(inputs.w.value) || 1920;
        canvas.height = parseInt(inputs.h.value) || 1080;
        drawFrame(state.currentTime);
    }

    function togglePlayback(recordingMode) {
        if(lyrics.length === 0) {
            alert("è¯·å…ˆå¯¼å…¥ SRT æ–‡ä»¶");
            return;
        }

        if(state.isPlaying) {
            stopPlayback();
            return;
        }

        // å¼€å§‹æ’­æ”¾/å½•åˆ¶
        state.isPlaying = true;
        state.isRecording = recordingMode;
        state.currentTime = 0;
        state.startTime = performance.now();
        
        // é”å®šè¾“å…¥
        btns.preview.disabled = true;
        btns.record.disabled = true;
        btns.stop.style.display = 'inline-block';

        if(recordingMode) {
            displays.rec.style.display = 'inline-block';
            startRecording();
        }

        loop();
    }

    function stopPlayback() {
        state.isPlaying = false;
        cancelAnimationFrame(animationId);
        
        btns.preview.disabled = false;
        btns.record.disabled = false;
        btns.stop.style.display = 'none';
        displays.rec.style.display = 'none';

        if(state.isRecording) {
            stopRecording();
            state.isRecording = false;
        }
    }

    function loop() {
        if(!state.isPlaying) return;

        const now = performance.now();
        const speed = parseFloat(inputs.speed.value) || 1;
        // è®¡ç®—ç»è¿‡çš„æ—¶é—´ (è€ƒè™‘å€é€Ÿ)
        const elapsed = (now - state.startTime) / 1000 * speed;
        
        state.currentTime = elapsed;

        if(state.currentTime >= state.duration) {
            state.currentTime = state.duration;
            drawFrame(state.currentTime);
            stopPlayback();
            return;
        }

        drawFrame(state.currentTime);
        displays.time.innerText = `${formatTime(state.currentTime)} / ${formatTime(state.duration)}`;
        
        animationId = requestAnimationFrame(loop);
    }

    // === Canvas ç»˜å›¾å¼•æ“ (Apple Style) ===
    function drawFrame(time) {
        const w = canvas.width;
        const h = canvas.height;
        const scale = Math.min(w, h) / 1080; // ç¼©æ”¾åŸºå‡†

        // 1. æ¸…ç©ºä¸èƒŒæ™¯
        ctx.clearRect(0, 0, w, h);
        
        if (backgroundImg) {
            // ç»˜åˆ¶èƒŒæ™¯å¹¶æ¨¡æ‹Ÿ Object-fit: cover
            const imgRatio = backgroundImg.width / backgroundImg.height;
            const canvasRatio = w / h;
            let dw, dh, dx, dy;
            if (canvasRatio > imgRatio) {
                dw = w; dh = w / imgRatio; dx = 0; dy = (h - dh) / 2;
            } else {
                dh = h; dw = h * imgRatio; dy = 0; dx = (w - dw) / 2;
            }
            
            // ç®€å•æ¨¡ç³Šæ¨¡æ‹Ÿï¼šå¤šæ¬¡ç»˜åˆ¶æˆ–ä½¿ç”¨ filter (æ³¨æ„ï¼šfilter åœ¨å½•åˆ¶æ—¶å¯èƒ½æ¶ˆè€—æ€§èƒ½)
            ctx.filter = 'blur(20px) brightness(0.7)';
            ctx.drawImage(backgroundImg, dx, dy, dw, dh);
            ctx.filter = 'none'; // é‡ç½® filter
        } else {
            // é»˜è®¤æ·±ç°è‰²èƒŒæ™¯
            ctx.fillStyle = "#1a1a1a";
            ctx.fillRect(0, 0, w, h);
        }

        // 2. å¸ƒå±€å¸¸é‡
        const headerY = h * 0.15;
        const controlsY = h - (h * 0.15);
        const progressY = controlsY - (100 * scale);
        
        // 3. ç»˜åˆ¶æ–‡å­—ä¿¡æ¯
        ctx.textAlign = 'center';
        
        // æ­Œå
        ctx.fillStyle = "#ffffff";
        ctx.font = `bold ${50 * scale}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.textBaseline = 'bottom';
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowBlur = 10;
        ctx.fillText(inputs.title.value, w / 2, headerY);
        
        // æ­Œæ‰‹
        ctx.fillStyle = "#cccccc";
        ctx.font = `${30 * scale}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.textBaseline = 'top';
        ctx.fillText(inputs.artist.value, w / 2, headerY + (15 * scale));

        // 4. ç»˜åˆ¶æ­Œè¯ (æ ¸å¿ƒ)
        const currentLyricObj = lyrics.find(l => time >= l.start && time <= l.end);
        
        // æ­Œè¯åŒºåŸŸä¸­å¿ƒ
        const lyricCenterY = (headerY + progressY) / 2;
        
        if (currentLyricObj) {
            const lines = currentLyricObj.text.split('\n');
            const fontSize = 80 * scale;
            const lineHeight = fontSize * 1.4;
            const totalHeight = lines.length * lineHeight;
            const startY = lyricCenterY - (totalHeight / 2) + (lineHeight/2);

            ctx.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, sans-serif`;
            ctx.fillStyle = "#ffffff";
            
            lines.forEach((line, i) => {
                ctx.fillText(line, w / 2, startY + i * lineHeight);
            });
        } else {
            // ç©ºç™½æœŸæ˜¾ç¤ºçœç•¥å·æˆ–ä¿æŒç©º
            // ctx.font = `bold ${60 * scale}px sans-serif`;
            // ctx.fillStyle = "rgba(255,255,255,0.3)";
            // ctx.fillText("...", w / 2, lyricCenterY);
        }

        // 5. ç»˜åˆ¶æ’­æ”¾å™¨ UI (è¿›åº¦æ¡ç­‰)
        const barWidth = w * 0.8;
        const barHeight = 10 * scale;
        const barX = (w - barWidth) / 2;

        // è¿›åº¦æ¡åº•
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.shadowBlur = 0; // å…³é—­é˜´å½±ç»˜åˆ¶UI
        ctx.beginPath();
        ctx.roundRect(barX, progressY, barWidth, barHeight, barHeight/2);
        ctx.fill();

        // è¿›åº¦æ¡å½“å‰
        const progress = Math.min(time / (state.duration || 1), 1);
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.roundRect(barX, progressY, barWidth * progress, barHeight, barHeight/2);
        ctx.fill();

        // è¿›åº¦çƒ (Thumb)
        const thumbX = barX + (barWidth * progress);
        ctx.beginPath();
        ctx.arc(thumbX, progressY + barHeight/2, barHeight * 1.5, 0, Math.PI * 2);
        ctx.fill();

        // æ—¶é—´æ–‡å­—
        ctx.font = `${24 * scale}px monospace`;
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        ctx.textBaseline = "middle";
        ctx.textAlign = "right";
        ctx.fillText(formatTime(time), barX - (20 * scale), progressY + barHeight/2);
        ctx.textAlign = "left";
        ctx.fillText("-" + formatTime(state.duration - time), barX + barWidth + (20 * scale), progressY + barHeight/2);

        // æŒ‰é’® (ç”»ç®€å•çš„å‡ ä½•å›¾å½¢æ¨¡æ‹Ÿ)
        const iconSize = 60 * scale;
        // æš‚åœ/æ’­æ”¾å›¾æ ‡ (å±…ä¸­)
        ctx.fillStyle = "#ffffff";
        // æ—¢ç„¶æ˜¯ç”Ÿæˆè§†é¢‘ï¼Œç”»é¢é‡Œä¸€èˆ¬æ˜¾ç¤ºçš„æ˜¯â€œæ’­æ”¾ä¸­â€çš„çŠ¶æ€ï¼Œä¹Ÿå°±æ˜¯æš‚åœå›¾æ ‡
        // æˆ–è€…æ˜¾ç¤ºæ’­æ”¾å›¾æ ‡è¡¨ç¤ºâ€œç‚¹å‡»æ’­æ”¾â€ã€‚è¿™é‡Œä¸ºäº†ç¾è§‚ï¼Œæˆ‘ä»¬ç”»ä¸€ä¸ªæš‚åœå›¾æ ‡
        if(state.isPlaying) {
             // æš‚åœå›¾æ ‡ (ä¸¤æ¡ç«–çº¿)
             const pauseW = iconSize / 3;
             ctx.fillRect((w/2) - pauseW + 5, controlsY - iconSize/2, 15 * scale, iconSize);
             ctx.fillRect((w/2) + 5, controlsY - iconSize/2, 15 * scale, iconSize);
        } else {
             // æ’­æ”¾å›¾æ ‡ (ä¸‰è§’å½¢)
             ctx.beginPath();
             ctx.moveTo((w/2) - iconSize/3, controlsY - iconSize/2);
             ctx.moveTo((w/2) + iconSize/1.5, controlsY);
             ctx.moveTo((w/2) - iconSize/3, controlsY + iconSize/2);
             ctx.fill();
        }
        
        // å·¦å³ç®­å¤´ (è£…é¥°)
        ctx.font = `${40 * scale}px sans-serif`;
        ctx.textAlign = "center";
        ctx.fillStyle = "rgba(255,255,255,0.5)";
        ctx.fillText("â®", w/2 - (150 * scale), controlsY + (15*scale));
        ctx.fillText("â­", w/2 + (150 * scale), controlsY + (15*scale));
    }

    // === è§†é¢‘å½•åˆ¶é€»è¾‘ ===
    function startRecording() {
        recordedChunks = [];
        // è·å– Canvas çš„åª’ä½“æµ (60 FPS)
        const stream = canvas.captureStream(60); 
        
        // å°è¯•ä½¿ç”¨é«˜è´¨é‡ç¼–ç 
        const options = { mimeType: 'video/webm; codecs=vp9' };
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
             options.mimeType = 'video/webm'; // é™çº§
        }

        mediaRecorder = new MediaRecorder(stream, options);

        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };

        mediaRecorder.onstop = exportVideo;
        mediaRecorder.start();
        console.log("å½•åˆ¶å¼€å§‹...");
    }

    function stopRecording() {
        if(mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            console.log("å½•åˆ¶ç»“æŸï¼Œå¤„ç†ä¸­...");
        }
    }

    function exportVideo() {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        
        // è‡ªåŠ¨ä¸‹è½½
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        a.download = `LyricVideo_${timestamp}.webm`;
        document.body.appendChild(a);
        a.click();
        
        // æ¸…ç†
        setTimeout(() => {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            alert("è§†é¢‘å·²ç”Ÿæˆå¹¶ä¸‹è½½ï¼");
        }, 100);
    }

    // === è¾…åŠ©å‡½æ•° ===
    function parseSRT(data) {
        const normalizedData = data.replace(/\r\n/g, '\n');
        const blocks = normalizedData.trim().split('\n\n');
        return blocks.map(block => {
            const lines = block.split('\n');
            if (lines.length < 2) return null;
            
            // æŸ¥æ‰¾æ—¶é—´è½´è¡Œ (åŒ…å« -->)
            const timeLineIndex = lines.findIndex(l => l.includes('-->'));
            if (timeLineIndex === -1) return null;

            const timeStr = lines[timeLineIndex];
            const textLines = lines.slice(timeLineIndex + 1);
            const [startStr, endStr] = timeStr.split(' --> ');

            return {
                start: timeToSeconds(startStr),
                end: timeToSeconds(endStr),
                text: textLines.join('\n')
            };
        }).filter(i => i !== null);
    }

    function timeToSeconds(t) {
        const [h, m, s] = t.split(':');
        const [sec, ms] = s.split(',');
        return parseInt(h)*3600 + parseInt(m)*60 + parseInt(sec) + parseInt(ms)/1000;
    }

    function formatTime(seconds) {
        if(isNaN(seconds)) return "0:00";
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
    }

    // Polyfill for roundRect if needed
    if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            this.beginPath();
            this.moveTo(x + r, y);
            this.arcTo(x + w, y, x + w, y + h, r);
            this.arcTo(x + w, y + h, x, y + h, r);
            this.arcTo(x, y + h, x, y, r);
            this.arcTo(x, y, x + w, y, r);
            this.closePath();
            return this;
        };
    }
</script>

</body>
</html>